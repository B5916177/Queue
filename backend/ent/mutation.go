// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/B5916177/app/ent/dentist"
	"github.com/B5916177/app/ent/employee"
	"github.com/B5916177/app/ent/patient"
	"github.com/B5916177/app/ent/queue"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDentist  = "Dentist"
	TypeEmployee = "Employee"
	TypePatient  = "Patient"
	TypeQueue    = "Queue"
)

// DentistMutation represents an operation that mutate the Dentists
// nodes in the graph.
type DentistMutation struct {
	config
	op               Op
	typ              string
	id               *int
	dentist_name     *string
	dentist_email    *string
	dentist_phone    *int
	adddentist_phone *int
	clearedFields    map[string]struct{}
	queue            map[int]struct{}
	removedqueue     map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Dentist, error)
}

var _ ent.Mutation = (*DentistMutation)(nil)

// dentistOption allows to manage the mutation configuration using functional options.
type dentistOption func(*DentistMutation)

// newDentistMutation creates new mutation for $n.Name.
func newDentistMutation(c config, op Op, opts ...dentistOption) *DentistMutation {
	m := &DentistMutation{
		config:        c,
		op:            op,
		typ:           TypeDentist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDentistID sets the id field of the mutation.
func withDentistID(id int) dentistOption {
	return func(m *DentistMutation) {
		var (
			err   error
			once  sync.Once
			value *Dentist
		)
		m.oldValue = func(ctx context.Context) (*Dentist, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dentist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDentist sets the old Dentist of the mutation.
func withDentist(node *Dentist) dentistOption {
	return func(m *DentistMutation) {
		m.oldValue = func(context.Context) (*Dentist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DentistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DentistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DentistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDentistName sets the dentist_name field.
func (m *DentistMutation) SetDentistName(s string) {
	m.dentist_name = &s
}

// DentistName returns the dentist_name value in the mutation.
func (m *DentistMutation) DentistName() (r string, exists bool) {
	v := m.dentist_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDentistName returns the old dentist_name value of the Dentist.
// If the Dentist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DentistMutation) OldDentistName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDentistName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDentistName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDentistName: %w", err)
	}
	return oldValue.DentistName, nil
}

// ResetDentistName reset all changes of the "dentist_name" field.
func (m *DentistMutation) ResetDentistName() {
	m.dentist_name = nil
}

// SetDentistEmail sets the dentist_email field.
func (m *DentistMutation) SetDentistEmail(s string) {
	m.dentist_email = &s
}

// DentistEmail returns the dentist_email value in the mutation.
func (m *DentistMutation) DentistEmail() (r string, exists bool) {
	v := m.dentist_email
	if v == nil {
		return
	}
	return *v, true
}

// OldDentistEmail returns the old dentist_email value of the Dentist.
// If the Dentist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DentistMutation) OldDentistEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDentistEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDentistEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDentistEmail: %w", err)
	}
	return oldValue.DentistEmail, nil
}

// ResetDentistEmail reset all changes of the "dentist_email" field.
func (m *DentistMutation) ResetDentistEmail() {
	m.dentist_email = nil
}

// SetDentistPhone sets the dentist_phone field.
func (m *DentistMutation) SetDentistPhone(i int) {
	m.dentist_phone = &i
	m.adddentist_phone = nil
}

// DentistPhone returns the dentist_phone value in the mutation.
func (m *DentistMutation) DentistPhone() (r int, exists bool) {
	v := m.dentist_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldDentistPhone returns the old dentist_phone value of the Dentist.
// If the Dentist object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DentistMutation) OldDentistPhone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDentistPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDentistPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDentistPhone: %w", err)
	}
	return oldValue.DentistPhone, nil
}

// AddDentistPhone adds i to dentist_phone.
func (m *DentistMutation) AddDentistPhone(i int) {
	if m.adddentist_phone != nil {
		*m.adddentist_phone += i
	} else {
		m.adddentist_phone = &i
	}
}

// AddedDentistPhone returns the value that was added to the dentist_phone field in this mutation.
func (m *DentistMutation) AddedDentistPhone() (r int, exists bool) {
	v := m.adddentist_phone
	if v == nil {
		return
	}
	return *v, true
}

// ResetDentistPhone reset all changes of the "dentist_phone" field.
func (m *DentistMutation) ResetDentistPhone() {
	m.dentist_phone = nil
	m.adddentist_phone = nil
}

// AddQueueIDs adds the queue edge to Queue by ids.
func (m *DentistMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to Queue by ids.
func (m *DentistMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *DentistMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *DentistMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *DentistMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *DentistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Dentist).
func (m *DentistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DentistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.dentist_name != nil {
		fields = append(fields, dentist.FieldDentistName)
	}
	if m.dentist_email != nil {
		fields = append(fields, dentist.FieldDentistEmail)
	}
	if m.dentist_phone != nil {
		fields = append(fields, dentist.FieldDentistPhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DentistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dentist.FieldDentistName:
		return m.DentistName()
	case dentist.FieldDentistEmail:
		return m.DentistEmail()
	case dentist.FieldDentistPhone:
		return m.DentistPhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DentistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dentist.FieldDentistName:
		return m.OldDentistName(ctx)
	case dentist.FieldDentistEmail:
		return m.OldDentistEmail(ctx)
	case dentist.FieldDentistPhone:
		return m.OldDentistPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Dentist field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DentistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dentist.FieldDentistName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDentistName(v)
		return nil
	case dentist.FieldDentistEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDentistEmail(v)
		return nil
	case dentist.FieldDentistPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDentistPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Dentist field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DentistMutation) AddedFields() []string {
	var fields []string
	if m.adddentist_phone != nil {
		fields = append(fields, dentist.FieldDentistPhone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DentistMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dentist.FieldDentistPhone:
		return m.AddedDentistPhone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DentistMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dentist.FieldDentistPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDentistPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Dentist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DentistMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DentistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DentistMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dentist nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DentistMutation) ResetField(name string) error {
	switch name {
	case dentist.FieldDentistName:
		m.ResetDentistName()
		return nil
	case dentist.FieldDentistEmail:
		m.ResetDentistEmail()
		return nil
	case dentist.FieldDentistPhone:
		m.ResetDentistPhone()
		return nil
	}
	return fmt.Errorf("unknown Dentist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DentistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.queue != nil {
		edges = append(edges, dentist.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DentistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dentist.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DentistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedqueue != nil {
		edges = append(edges, dentist.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DentistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dentist.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DentistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DentistMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DentistMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dentist unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DentistMutation) ResetEdge(name string) error {
	switch name {
	case dentist.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown Dentist edge %s", name)
}

// EmployeeMutation represents an operation that mutate the Employees
// nodes in the graph.
type EmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	employee_name     *string
	employee_email    *string
	employee_password *string
	employee_phone    *int
	addemployee_phone *int
	clearedFields     map[string]struct{}
	queue             map[int]struct{}
	removedqueue      map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Employee, error)
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows to manage the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for $n.Name.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the id field of the mutation.
func withEmployeeID(id int) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *EmployeeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmployeeName sets the employee_name field.
func (m *EmployeeMutation) SetEmployeeName(s string) {
	m.employee_name = &s
}

// EmployeeName returns the employee_name value in the mutation.
func (m *EmployeeMutation) EmployeeName() (r string, exists bool) {
	v := m.employee_name
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeName returns the old employee_name value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeName: %w", err)
	}
	return oldValue.EmployeeName, nil
}

// ResetEmployeeName reset all changes of the "employee_name" field.
func (m *EmployeeMutation) ResetEmployeeName() {
	m.employee_name = nil
}

// SetEmployeeEmail sets the employee_email field.
func (m *EmployeeMutation) SetEmployeeEmail(s string) {
	m.employee_email = &s
}

// EmployeeEmail returns the employee_email value in the mutation.
func (m *EmployeeMutation) EmployeeEmail() (r string, exists bool) {
	v := m.employee_email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeEmail returns the old employee_email value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeeEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeeEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeeEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeEmail: %w", err)
	}
	return oldValue.EmployeeEmail, nil
}

// ResetEmployeeEmail reset all changes of the "employee_email" field.
func (m *EmployeeMutation) ResetEmployeeEmail() {
	m.employee_email = nil
}

// SetEmployeePassword sets the employee_password field.
func (m *EmployeeMutation) SetEmployeePassword(s string) {
	m.employee_password = &s
}

// EmployeePassword returns the employee_password value in the mutation.
func (m *EmployeeMutation) EmployeePassword() (r string, exists bool) {
	v := m.employee_password
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePassword returns the old employee_password value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeePassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePassword: %w", err)
	}
	return oldValue.EmployeePassword, nil
}

// ResetEmployeePassword reset all changes of the "employee_password" field.
func (m *EmployeeMutation) ResetEmployeePassword() {
	m.employee_password = nil
}

// SetEmployeePhone sets the employee_phone field.
func (m *EmployeeMutation) SetEmployeePhone(i int) {
	m.employee_phone = &i
	m.addemployee_phone = nil
}

// EmployeePhone returns the employee_phone value in the mutation.
func (m *EmployeeMutation) EmployeePhone() (r int, exists bool) {
	v := m.employee_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeePhone returns the old employee_phone value of the Employee.
// If the Employee object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *EmployeeMutation) OldEmployeePhone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmployeePhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmployeePhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeePhone: %w", err)
	}
	return oldValue.EmployeePhone, nil
}

// AddEmployeePhone adds i to employee_phone.
func (m *EmployeeMutation) AddEmployeePhone(i int) {
	if m.addemployee_phone != nil {
		*m.addemployee_phone += i
	} else {
		m.addemployee_phone = &i
	}
}

// AddedEmployeePhone returns the value that was added to the employee_phone field in this mutation.
func (m *EmployeeMutation) AddedEmployeePhone() (r int, exists bool) {
	v := m.addemployee_phone
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmployeePhone reset all changes of the "employee_phone" field.
func (m *EmployeeMutation) ResetEmployeePhone() {
	m.employee_phone = nil
	m.addemployee_phone = nil
}

// AddQueueIDs adds the queue edge to Queue by ids.
func (m *EmployeeMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to Queue by ids.
func (m *EmployeeMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *EmployeeMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *EmployeeMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *EmployeeMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.employee_name != nil {
		fields = append(fields, employee.FieldEmployeeName)
	}
	if m.employee_email != nil {
		fields = append(fields, employee.FieldEmployeeEmail)
	}
	if m.employee_password != nil {
		fields = append(fields, employee.FieldEmployeePassword)
	}
	if m.employee_phone != nil {
		fields = append(fields, employee.FieldEmployeePhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeeName:
		return m.EmployeeName()
	case employee.FieldEmployeeEmail:
		return m.EmployeeEmail()
	case employee.FieldEmployeePassword:
		return m.EmployeePassword()
	case employee.FieldEmployeePhone:
		return m.EmployeePhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldEmployeeName:
		return m.OldEmployeeName(ctx)
	case employee.FieldEmployeeEmail:
		return m.OldEmployeeEmail(ctx)
	case employee.FieldEmployeePassword:
		return m.OldEmployeePassword(ctx)
	case employee.FieldEmployeePhone:
		return m.OldEmployeePhone(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeName(v)
		return nil
	case employee.FieldEmployeeEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeEmail(v)
		return nil
	case employee.FieldEmployeePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePassword(v)
		return nil
	case employee.FieldEmployeePhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeePhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	if m.addemployee_phone != nil {
		fields = append(fields, employee.FieldEmployeePhone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldEmployeePhone:
		return m.AddedEmployeePhone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case employee.FieldEmployeePhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmployeePhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldEmployeeName:
		m.ResetEmployeeName()
		return nil
	case employee.FieldEmployeeEmail:
		m.ResetEmployeeEmail()
		return nil
	case employee.FieldEmployeePassword:
		m.ResetEmployeePassword()
		return nil
	case employee.FieldEmployeePhone:
		m.ResetEmployeePhone()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.queue != nil {
		edges = append(edges, employee.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedqueue != nil {
		edges = append(edges, employee.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// PatientMutation represents an operation that mutate the Patients
// nodes in the graph.
type PatientMutation struct {
	config
	op               Op
	typ              string
	id               *int
	patient_name     *string
	patient_gender   *string
	patient_age      *int
	addpatient_age   *int
	patient_phone    *int
	addpatient_phone *int
	clearedFields    map[string]struct{}
	queue            map[int]struct{}
	removedqueue     map[int]struct{}
	done             bool
	oldValue         func(context.Context) (*Patient, error)
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows to manage the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for $n.Name.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the id field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientName sets the patient_name field.
func (m *PatientMutation) SetPatientName(s string) {
	m.patient_name = &s
}

// PatientName returns the patient_name value in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m.patient_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old patient_name value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName reset all changes of the "patient_name" field.
func (m *PatientMutation) ResetPatientName() {
	m.patient_name = nil
}

// SetPatientGender sets the patient_gender field.
func (m *PatientMutation) SetPatientGender(s string) {
	m.patient_gender = &s
}

// PatientGender returns the patient_gender value in the mutation.
func (m *PatientMutation) PatientGender() (r string, exists bool) {
	v := m.patient_gender
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientGender returns the old patient_gender value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientGender is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientGender: %w", err)
	}
	return oldValue.PatientGender, nil
}

// ResetPatientGender reset all changes of the "patient_gender" field.
func (m *PatientMutation) ResetPatientGender() {
	m.patient_gender = nil
}

// SetPatientAge sets the patient_age field.
func (m *PatientMutation) SetPatientAge(i int) {
	m.patient_age = &i
	m.addpatient_age = nil
}

// PatientAge returns the patient_age value in the mutation.
func (m *PatientMutation) PatientAge() (r int, exists bool) {
	v := m.patient_age
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientAge returns the old patient_age value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientAge: %w", err)
	}
	return oldValue.PatientAge, nil
}

// AddPatientAge adds i to patient_age.
func (m *PatientMutation) AddPatientAge(i int) {
	if m.addpatient_age != nil {
		*m.addpatient_age += i
	} else {
		m.addpatient_age = &i
	}
}

// AddedPatientAge returns the value that was added to the patient_age field in this mutation.
func (m *PatientMutation) AddedPatientAge() (r int, exists bool) {
	v := m.addpatient_age
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientAge reset all changes of the "patient_age" field.
func (m *PatientMutation) ResetPatientAge() {
	m.patient_age = nil
	m.addpatient_age = nil
}

// SetPatientPhone sets the patient_phone field.
func (m *PatientMutation) SetPatientPhone(i int) {
	m.patient_phone = &i
	m.addpatient_phone = nil
}

// PatientPhone returns the patient_phone value in the mutation.
func (m *PatientMutation) PatientPhone() (r int, exists bool) {
	v := m.patient_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientPhone returns the old patient_phone value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientPhone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientPhone is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientPhone: %w", err)
	}
	return oldValue.PatientPhone, nil
}

// AddPatientPhone adds i to patient_phone.
func (m *PatientMutation) AddPatientPhone(i int) {
	if m.addpatient_phone != nil {
		*m.addpatient_phone += i
	} else {
		m.addpatient_phone = &i
	}
}

// AddedPatientPhone returns the value that was added to the patient_phone field in this mutation.
func (m *PatientMutation) AddedPatientPhone() (r int, exists bool) {
	v := m.addpatient_phone
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientPhone reset all changes of the "patient_phone" field.
func (m *PatientMutation) ResetPatientPhone() {
	m.patient_phone = nil
	m.addpatient_phone = nil
}

// AddQueueIDs adds the queue edge to Queue by ids.
func (m *PatientMutation) AddQueueIDs(ids ...int) {
	if m.queue == nil {
		m.queue = make(map[int]struct{})
	}
	for i := range ids {
		m.queue[ids[i]] = struct{}{}
	}
}

// RemoveQueueIDs removes the queue edge to Queue by ids.
func (m *PatientMutation) RemoveQueueIDs(ids ...int) {
	if m.removedqueue == nil {
		m.removedqueue = make(map[int]struct{})
	}
	for i := range ids {
		m.removedqueue[ids[i]] = struct{}{}
	}
}

// RemovedQueue returns the removed ids of queue.
func (m *PatientMutation) RemovedQueueIDs() (ids []int) {
	for id := range m.removedqueue {
		ids = append(ids, id)
	}
	return
}

// QueueIDs returns the queue ids in the mutation.
func (m *PatientMutation) QueueIDs() (ids []int) {
	for id := range m.queue {
		ids = append(ids, id)
	}
	return
}

// ResetQueue reset all changes of the "queue" edge.
func (m *PatientMutation) ResetQueue() {
	m.queue = nil
	m.removedqueue = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.patient_name != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m.patient_gender != nil {
		fields = append(fields, patient.FieldPatientGender)
	}
	if m.patient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	if m.patient_phone != nil {
		fields = append(fields, patient.FieldPatientPhone)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldPatientGender:
		return m.PatientGender()
	case patient.FieldPatientAge:
		return m.PatientAge()
	case patient.FieldPatientPhone:
		return m.PatientPhone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldPatientGender:
		return m.OldPatientGender(ctx)
	case patient.FieldPatientAge:
		return m.OldPatientAge(ctx)
	case patient.FieldPatientPhone:
		return m.OldPatientPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldPatientGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientGender(v)
		return nil
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientAge(v)
		return nil
	case patient.FieldPatientPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.addpatient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	if m.addpatient_phone != nil {
		fields = append(fields, patient.FieldPatientPhone)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientAge:
		return m.AddedPatientAge()
	case patient.FieldPatientPhone:
		return m.AddedPatientPhone()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientAge(v)
		return nil
	case patient.FieldPatientPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldPatientGender:
		m.ResetPatientGender()
		return nil
	case patient.FieldPatientAge:
		m.ResetPatientAge()
		return nil
	case patient.FieldPatientPhone:
		m.ResetPatientPhone()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.queue != nil {
		edges = append(edges, patient.EdgeQueue)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.queue))
		for id := range m.queue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedqueue != nil {
		edges = append(edges, patient.EdgeQueue)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeQueue:
		ids := make([]ent.Value, 0, len(m.removedqueue))
		for id := range m.removedqueue {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeQueue:
		m.ResetQueue()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// QueueMutation represents an operation that mutate the Queues
// nodes in the graph.
type QueueMutation struct {
	config
	op              Op
	typ             string
	id              *int
	dental          *string
	queue_time      *time.Time
	clearedFields   map[string]struct{}
	dentist         *int
	cleareddentist  bool
	employee        *int
	clearedemployee bool
	patient         *int
	clearedpatient  bool
	done            bool
	oldValue        func(context.Context) (*Queue, error)
}

var _ ent.Mutation = (*QueueMutation)(nil)

// queueOption allows to manage the mutation configuration using functional options.
type queueOption func(*QueueMutation)

// newQueueMutation creates new mutation for $n.Name.
func newQueueMutation(c config, op Op, opts ...queueOption) *QueueMutation {
	m := &QueueMutation{
		config:        c,
		op:            op,
		typ:           TypeQueue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQueueID sets the id field of the mutation.
func withQueueID(id int) queueOption {
	return func(m *QueueMutation) {
		var (
			err   error
			once  sync.Once
			value *Queue
		)
		m.oldValue = func(ctx context.Context) (*Queue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Queue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQueue sets the old Queue of the mutation.
func withQueue(node *Queue) queueOption {
	return func(m *QueueMutation) {
		m.oldValue = func(context.Context) (*Queue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QueueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QueueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *QueueMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDental sets the dental field.
func (m *QueueMutation) SetDental(s string) {
	m.dental = &s
}

// Dental returns the dental value in the mutation.
func (m *QueueMutation) Dental() (r string, exists bool) {
	v := m.dental
	if v == nil {
		return
	}
	return *v, true
}

// OldDental returns the old dental value of the Queue.
// If the Queue object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueMutation) OldDental(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDental is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDental requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDental: %w", err)
	}
	return oldValue.Dental, nil
}

// ResetDental reset all changes of the "dental" field.
func (m *QueueMutation) ResetDental() {
	m.dental = nil
}

// SetQueueTime sets the queue_time field.
func (m *QueueMutation) SetQueueTime(t time.Time) {
	m.queue_time = &t
}

// QueueTime returns the queue_time value in the mutation.
func (m *QueueMutation) QueueTime() (r time.Time, exists bool) {
	v := m.queue_time
	if v == nil {
		return
	}
	return *v, true
}

// OldQueueTime returns the old queue_time value of the Queue.
// If the Queue object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *QueueMutation) OldQueueTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQueueTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQueueTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueueTime: %w", err)
	}
	return oldValue.QueueTime, nil
}

// ResetQueueTime reset all changes of the "queue_time" field.
func (m *QueueMutation) ResetQueueTime() {
	m.queue_time = nil
}

// SetDentistID sets the dentist edge to Dentist by id.
func (m *QueueMutation) SetDentistID(id int) {
	m.dentist = &id
}

// ClearDentist clears the dentist edge to Dentist.
func (m *QueueMutation) ClearDentist() {
	m.cleareddentist = true
}

// DentistCleared returns if the edge dentist was cleared.
func (m *QueueMutation) DentistCleared() bool {
	return m.cleareddentist
}

// DentistID returns the dentist id in the mutation.
func (m *QueueMutation) DentistID() (id int, exists bool) {
	if m.dentist != nil {
		return *m.dentist, true
	}
	return
}

// DentistIDs returns the dentist ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DentistID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) DentistIDs() (ids []int) {
	if id := m.dentist; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDentist reset all changes of the "dentist" edge.
func (m *QueueMutation) ResetDentist() {
	m.dentist = nil
	m.cleareddentist = false
}

// SetEmployeeID sets the employee edge to Employee by id.
func (m *QueueMutation) SetEmployeeID(id int) {
	m.employee = &id
}

// ClearEmployee clears the employee edge to Employee.
func (m *QueueMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared returns if the edge employee was cleared.
func (m *QueueMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeID returns the employee id in the mutation.
func (m *QueueMutation) EmployeeID() (id int, exists bool) {
	if m.employee != nil {
		return *m.employee, true
	}
	return
}

// EmployeeIDs returns the employee ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) EmployeeIDs() (ids []int) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee reset all changes of the "employee" edge.
func (m *QueueMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetPatientID sets the patient edge to Patient by id.
func (m *QueueMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to Patient.
func (m *QueueMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *QueueMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *QueueMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *QueueMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *QueueMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// Op returns the operation name.
func (m *QueueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Queue).
func (m *QueueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *QueueMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.dental != nil {
		fields = append(fields, queue.FieldDental)
	}
	if m.queue_time != nil {
		fields = append(fields, queue.FieldQueueTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *QueueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case queue.FieldDental:
		return m.Dental()
	case queue.FieldQueueTime:
		return m.QueueTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *QueueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case queue.FieldDental:
		return m.OldDental(ctx)
	case queue.FieldQueueTime:
		return m.OldQueueTime(ctx)
	}
	return nil, fmt.Errorf("unknown Queue field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case queue.FieldDental:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDental(v)
		return nil
	case queue.FieldQueueTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueueTime(v)
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *QueueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *QueueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *QueueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Queue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *QueueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *QueueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *QueueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Queue nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *QueueMutation) ResetField(name string) error {
	switch name {
	case queue.FieldDental:
		m.ResetDental()
		return nil
	case queue.FieldQueueTime:
		m.ResetQueueTime()
		return nil
	}
	return fmt.Errorf("unknown Queue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *QueueMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.dentist != nil {
		edges = append(edges, queue.EdgeDentist)
	}
	if m.employee != nil {
		edges = append(edges, queue.EdgeEmployee)
	}
	if m.patient != nil {
		edges = append(edges, queue.EdgePatient)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *QueueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case queue.EdgeDentist:
		if id := m.dentist; id != nil {
			return []ent.Value{*id}
		}
	case queue.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case queue.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *QueueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *QueueMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *QueueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareddentist {
		edges = append(edges, queue.EdgeDentist)
	}
	if m.clearedemployee {
		edges = append(edges, queue.EdgeEmployee)
	}
	if m.clearedpatient {
		edges = append(edges, queue.EdgePatient)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *QueueMutation) EdgeCleared(name string) bool {
	switch name {
	case queue.EdgeDentist:
		return m.cleareddentist
	case queue.EdgeEmployee:
		return m.clearedemployee
	case queue.EdgePatient:
		return m.clearedpatient
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *QueueMutation) ClearEdge(name string) error {
	switch name {
	case queue.EdgeDentist:
		m.ClearDentist()
		return nil
	case queue.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case queue.EdgePatient:
		m.ClearPatient()
		return nil
	}
	return fmt.Errorf("unknown Queue unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *QueueMutation) ResetEdge(name string) error {
	switch name {
	case queue.EdgeDentist:
		m.ResetDentist()
		return nil
	case queue.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case queue.EdgePatient:
		m.ResetPatient()
		return nil
	}
	return fmt.Errorf("unknown Queue edge %s", name)
}
